  // Copyright (c) Obelisk Labs, Inc.
  // SPDX-License-Identifier: Apache-2.0
  #[allow(unused_use)]
  
  /* Autogenerated file. Do not edit manually. */
  
  module numeron::numeron_schema {

  use std::ascii::String;

  use std::ascii::string;

  use sui::package::UpgradeCap;

  use std::type_name;

  use dubhe::storage;

  use dubhe::storage_value::{Self, StorageValue};

  use dubhe::storage_map::{Self, StorageMap};

  use dubhe::storage_double_map::{Self, StorageDoubleMap};

  use sui::dynamic_field as df;

  use numeron::numeron_monster_type::MonsterType;

  use numeron::numeron_monster_ball_type::MonsterBallType;

  use numeron::numeron_monster_catch_result::MonsterCatchResult;

  use numeron::numeron_map_config::MapConfig;

  use numeron::numeron_position::Position;

  use numeron::numeron_encounter_info::EncounterInfo;

  use numeron::numeron_stats::Stats;

  use numeron::numeron_monster_info::MonsterInfo;

  use numeron::numeron_item_type::ItemType;

  use numeron::numeron_item_metadata::ItemMetadata;

  use numeron::numeron_item::Item;

  use numeron::numeron_item_drop::ItemDrop;

  use numeron::numeron_craft_path::CraftPath;

  use numeron::numeron_swap_order::SwapOrder;

  use numeron::numeron_trade_order::TradeOrder;

  public struct Schema has key, store {
    id: UID,
  }

  public fun borrow_encounter(self: &Schema): &StorageMap<address, EncounterInfo> {
    storage::borrow_field(&self.id, b"encounter")
  }

  public(package) fun encounter(self: &mut Schema): &mut StorageMap<address, EncounterInfo> {
    storage::borrow_mut_field(&mut self.id, b"encounter")
  }

  public fun borrow_encounter_monster(self: &Schema): &StorageValue<vector<MonsterInfo>> {
    storage::borrow_field(&self.id, b"encounter_monster")
  }

  public(package) fun encounter_monster(self: &mut Schema): &mut StorageValue<vector<MonsterInfo>> {
    storage::borrow_mut_field(&mut self.id, b"encounter_monster")
  }

  public fun borrow_player(self: &Schema): &StorageMap<address, bool> {
    storage::borrow_field(&self.id, b"player")
  }

  public(package) fun player(self: &mut Schema): &mut StorageMap<address, bool> {
    storage::borrow_mut_field(&mut self.id, b"player")
  }

  public fun borrow_obstruction(self: &Schema): &StorageMap<Position, bool> {
    storage::borrow_field(&self.id, b"obstruction")
  }

  public(package) fun obstruction(self: &mut Schema): &mut StorageMap<Position, bool> {
    storage::borrow_mut_field(&mut self.id, b"obstruction")
  }

  public fun borrow_encounter_trigger(self: &Schema): &StorageMap<Position, bool> {
    storage::borrow_field(&self.id, b"encounter_trigger")
  }

  public(package) fun encounter_trigger(self: &mut Schema): &mut StorageMap<Position, bool> {
    storage::borrow_mut_field(&mut self.id, b"encounter_trigger")
  }

  public fun borrow_map_layer(self: &Schema): &StorageDoubleMap<u64, String, vector<u8>> {
    storage::borrow_field(&self.id, b"map_layer")
  }

  public(package) fun map_layer(self: &mut Schema): &mut StorageDoubleMap<u64, String, vector<u8>> {
    storage::borrow_mut_field(&mut self.id, b"map_layer")
  }

  public fun borrow_map_config(self: &Schema): &StorageMap<u64, MapConfig> {
    storage::borrow_field(&self.id, b"map_config")
  }

  public(package) fun map_config(self: &mut Schema): &mut StorageMap<u64, MapConfig> {
    storage::borrow_mut_field(&mut self.id, b"map_config")
  }

  public fun borrow_position(self: &Schema): &StorageMap<address, Position> {
    storage::borrow_field(&self.id, b"position")
  }

  public(package) fun position(self: &mut Schema): &mut StorageMap<address, Position> {
    storage::borrow_mut_field(&mut self.id, b"position")
  }

  public fun borrow_monster(self: &Schema): &StorageMap<u256, MonsterInfo> {
    storage::borrow_field(&self.id, b"monster")
  }

  public(package) fun monster(self: &mut Schema): &mut StorageMap<u256, MonsterInfo> {
    storage::borrow_mut_field(&mut self.id, b"monster")
  }

  public fun borrow_next_monster_id(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"next_monster_id")
  }

  public(package) fun next_monster_id(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"next_monster_id")
  }

  public fun borrow_next_item_id(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"next_item_id")
  }

  public(package) fun next_item_id(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"next_item_id")
  }

  public fun borrow_monster_owned_by(self: &Schema): &StorageMap<address, vector<u256>> {
    storage::borrow_field(&self.id, b"monster_owned_by")
  }

  public(package) fun monster_owned_by(self: &mut Schema): &mut StorageMap<address, vector<u256>> {
    storage::borrow_mut_field(&mut self.id, b"monster_owned_by")
  }

  public fun borrow_balance(self: &Schema): &StorageDoubleMap<address, u256, u256> {
    storage::borrow_field(&self.id, b"balance")
  }

  public(package) fun balance(self: &mut Schema): &mut StorageDoubleMap<address, u256, u256> {
    storage::borrow_mut_field(&mut self.id, b"balance")
  }

  public fun borrow_item_metadata(self: &Schema): &StorageMap<u256, ItemMetadata> {
    storage::borrow_field(&self.id, b"item_metadata")
  }

  public(package) fun item_metadata(self: &mut Schema): &mut StorageMap<u256, ItemMetadata> {
    storage::borrow_mut_field(&mut self.id, b"item_metadata")
  }

  public fun borrow_move_item_drop_config(self: &Schema): &StorageValue<ItemDrop> {
    storage::borrow_field(&self.id, b"move_item_drop_config")
  }

  public(package) fun move_item_drop_config(self: &mut Schema): &mut StorageValue<ItemDrop> {
    storage::borrow_mut_field(&mut self.id, b"move_item_drop_config")
  }

  public fun borrow_chest_item_drop_config(self: &Schema): &StorageMap<u256, ItemDrop> {
    storage::borrow_field(&self.id, b"chest_item_drop_config")
  }

  public(package) fun chest_item_drop_config(self: &mut Schema): &mut StorageMap<u256, ItemDrop> {
    storage::borrow_mut_field(&mut self.id, b"chest_item_drop_config")
  }

  public fun borrow_encounter_item_drop_config(self: &Schema): &StorageValue<ItemDrop> {
    storage::borrow_field(&self.id, b"encounter_item_drop_config")
  }

  public(package) fun encounter_item_drop_config(self: &mut Schema): &mut StorageValue<ItemDrop> {
    storage::borrow_mut_field(&mut self.id, b"encounter_item_drop_config")
  }

  public fun borrow_item_craft_path(self: &Schema): &StorageMap<u256, CraftPath> {
    storage::borrow_field(&self.id, b"item_craft_path")
  }

  public(package) fun item_craft_path(self: &mut Schema): &mut StorageMap<u256, CraftPath> {
    storage::borrow_mut_field(&mut self.id, b"item_craft_path")
  }

  public fun borrow_teleport_point(self: &Schema): &StorageMap<Position, Position> {
    storage::borrow_field(&self.id, b"teleport_point")
  }

  public(package) fun teleport_point(self: &mut Schema): &mut StorageMap<Position, Position> {
    storage::borrow_mut_field(&mut self.id, b"teleport_point")
  }

  public fun borrow_stats(self: &Schema): &StorageMap<address, Stats> {
    storage::borrow_field(&self.id, b"stats")
  }

  public(package) fun stats(self: &mut Schema): &mut StorageMap<address, Stats> {
    storage::borrow_mut_field(&mut self.id, b"stats")
  }

  public fun borrow_swap_order(self: &Schema): &StorageMap<u256, SwapOrder> {
    storage::borrow_field(&self.id, b"swap_order")
  }

  public(package) fun swap_order(self: &mut Schema): &mut StorageMap<u256, SwapOrder> {
    storage::borrow_mut_field(&mut self.id, b"swap_order")
  }

  public fun borrow_trade_order(self: &Schema): &StorageMap<u256, TradeOrder> {
    storage::borrow_field(&self.id, b"trade_order")
  }

  public(package) fun trade_order(self: &mut Schema): &mut StorageMap<u256, TradeOrder> {
    storage::borrow_mut_field(&mut self.id, b"trade_order")
  }

  public fun borrow_next_order_id(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"next_order_id")
  }

  public(package) fun next_order_id(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"next_order_id")
  }

  public fun borrow_num_asset_id(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"num_asset_id")
  }

  public(package) fun num_asset_id(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"num_asset_id")
  }

  public fun borrow_key_price(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"key_price")
  }

  public(package) fun key_price(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"key_price")
  }

  public fun borrow_order_fee_rate(self: &Schema): &StorageValue<u256> {
    storage::borrow_field(&self.id, b"order_fee_rate")
  }

  public(package) fun order_fee_rate(self: &mut Schema): &mut StorageValue<u256> {
    storage::borrow_mut_field(&mut self.id, b"order_fee_rate")
  }

  public(package) fun create(ctx: &mut TxContext): Schema {
    let mut id = object::new(ctx);
    storage::add_field<StorageMap<address, EncounterInfo>>(&mut id, b"encounter", storage_map::new(b"encounter", ctx));
    storage::add_field<StorageValue<vector<MonsterInfo>>>(&mut id, b"encounter_monster", storage_value::new(b"encounter_monster", ctx));
    storage::add_field<StorageMap<address, bool>>(&mut id, b"player", storage_map::new(b"player", ctx));
    storage::add_field<StorageMap<Position, bool>>(&mut id, b"obstruction", storage_map::new(b"obstruction", ctx));
    storage::add_field<StorageMap<Position, bool>>(&mut id, b"encounter_trigger", storage_map::new(b"encounter_trigger", ctx));
    storage::add_field<StorageDoubleMap<u64, String, vector<u8>>>(&mut id, b"map_layer", storage_double_map::new(b"map_layer", ctx));
    storage::add_field<StorageMap<u64, MapConfig>>(&mut id, b"map_config", storage_map::new(b"map_config", ctx));
    storage::add_field<StorageMap<address, Position>>(&mut id, b"position", storage_map::new(b"position", ctx));
    storage::add_field<StorageMap<u256, MonsterInfo>>(&mut id, b"monster", storage_map::new(b"monster", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"next_monster_id", storage_value::new(b"next_monster_id", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"next_item_id", storage_value::new(b"next_item_id", ctx));
    storage::add_field<StorageMap<address, vector<u256>>>(&mut id, b"monster_owned_by", storage_map::new(b"monster_owned_by", ctx));
    storage::add_field<StorageDoubleMap<address, u256, u256>>(&mut id, b"balance", storage_double_map::new(b"balance", ctx));
    storage::add_field<StorageMap<u256, ItemMetadata>>(&mut id, b"item_metadata", storage_map::new(b"item_metadata", ctx));
    storage::add_field<StorageValue<ItemDrop>>(&mut id, b"move_item_drop_config", storage_value::new(b"move_item_drop_config", ctx));
    storage::add_field<StorageMap<u256, ItemDrop>>(&mut id, b"chest_item_drop_config", storage_map::new(b"chest_item_drop_config", ctx));
    storage::add_field<StorageValue<ItemDrop>>(&mut id, b"encounter_item_drop_config", storage_value::new(b"encounter_item_drop_config", ctx));
    storage::add_field<StorageMap<u256, CraftPath>>(&mut id, b"item_craft_path", storage_map::new(b"item_craft_path", ctx));
    storage::add_field<StorageMap<Position, Position>>(&mut id, b"teleport_point", storage_map::new(b"teleport_point", ctx));
    storage::add_field<StorageMap<address, Stats>>(&mut id, b"stats", storage_map::new(b"stats", ctx));
    storage::add_field<StorageMap<u256, SwapOrder>>(&mut id, b"swap_order", storage_map::new(b"swap_order", ctx));
    storage::add_field<StorageMap<u256, TradeOrder>>(&mut id, b"trade_order", storage_map::new(b"trade_order", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"next_order_id", storage_value::new(b"next_order_id", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"num_asset_id", storage_value::new(b"num_asset_id", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"key_price", storage_value::new(b"key_price", ctx));
    storage::add_field<StorageValue<u256>>(&mut id, b"order_fee_rate", storage_value::new(b"order_fee_rate", ctx));
    Schema { id }
  }

  public(package) fun id(self: &mut Schema): &mut UID {
    &mut self.id
  }

  public(package) fun borrow_id(self: &Schema): &UID {
    &self.id
  }

  public fun migrate(_schema: &mut Schema, _ctx: &mut TxContext) {}

  // ======================================== View Functions ========================================

  public fun get_encounter(self: &Schema, key: address): &EncounterInfo {
    self.borrow_encounter().get(key)
  }

  public fun get_encounter_monster(self: &Schema): &vector<MonsterInfo> {
    self.borrow_encounter_monster().get()
  }

  public fun get_player(self: &Schema, key: address): &bool {
    self.borrow_player().get(key)
  }

  public fun get_obstruction(self: &Schema, key: Position): &bool {
    self.borrow_obstruction().get(key)
  }

  public fun get_encounter_trigger(self: &Schema, key: Position): &bool {
    self.borrow_encounter_trigger().get(key)
  }

  public fun get_map_layer(self: &Schema, key1: u64, key2: String): &vector<u8> {
    self.borrow_map_layer().get(key1, key2)
  }

  public fun get_map_config(self: &Schema, key: u64): &MapConfig {
    self.borrow_map_config().get(key)
  }

  public fun get_position(self: &Schema, key: address): &Position {
    self.borrow_position().get(key)
  }

  public fun get_monster(self: &Schema, key: u256): &MonsterInfo {
    self.borrow_monster().get(key)
  }

  public fun get_next_monster_id(self: &Schema): &u256 {
    self.borrow_next_monster_id().get()
  }

  public fun get_next_item_id(self: &Schema): &u256 {
    self.borrow_next_item_id().get()
  }

  public fun get_monster_owned_by(self: &Schema, key: address): &vector<u256> {
    self.borrow_monster_owned_by().get(key)
  }

  public fun get_balance(self: &Schema, key1: address, key2: u256): &u256 {
    self.borrow_balance().get(key1, key2)
  }

  public fun get_item_metadata(self: &Schema, key: u256): &ItemMetadata {
    self.borrow_item_metadata().get(key)
  }

  public fun get_move_item_drop_config(self: &Schema): &ItemDrop {
    self.borrow_move_item_drop_config().get()
  }

  public fun get_chest_item_drop_config(self: &Schema, key: u256): &ItemDrop {
    self.borrow_chest_item_drop_config().get(key)
  }

  public fun get_encounter_item_drop_config(self: &Schema): &ItemDrop {
    self.borrow_encounter_item_drop_config().get()
  }

  public fun get_item_craft_path(self: &Schema, key: u256): &CraftPath {
    self.borrow_item_craft_path().get(key)
  }

  public fun get_teleport_point(self: &Schema, key: Position): &Position {
    self.borrow_teleport_point().get(key)
  }

  public fun get_stats(self: &Schema, key: address): &Stats {
    self.borrow_stats().get(key)
  }

  public fun get_swap_order(self: &Schema, key: u256): &SwapOrder {
    self.borrow_swap_order().get(key)
  }

  public fun get_trade_order(self: &Schema, key: u256): &TradeOrder {
    self.borrow_trade_order().get(key)
  }

  public fun get_next_order_id(self: &Schema): &u256 {
    self.borrow_next_order_id().get()
  }

  public fun get_num_asset_id(self: &Schema): &u256 {
    self.borrow_num_asset_id().get()
  }

  public fun get_key_price(self: &Schema): &u256 {
    self.borrow_key_price().get()
  }

  public fun get_order_fee_rate(self: &Schema): &u256 {
    self.borrow_order_fee_rate().get()
  }

  // =========================================================================================================
}
